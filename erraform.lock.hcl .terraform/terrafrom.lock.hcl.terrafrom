terraform used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
  [32m+[0m create[0m

Terraform will perform the following actions:

[1m  # docker_container.nginx_container[0m will be created
[0m  [32m+[0m[0m resource "docker_container" "nginx_container" {
      [32m+[0m[0m attach                                      = false
      [32m+[0m[0m bridge                                      = (known after apply)
      [32m+[0m[0m command                                     = (known after apply)
      [32m+[0m[0m container_logs                              = (known after apply)
      [32m+[0m[0m container_read_refresh_timeout_milliseconds = 15000
      [32m+[0m[0m entrypoint                                  = (known after apply)
      [32m+[0m[0m env                                         = (known after apply)
      [32m+[0m[0m exit_code                                   = (known after apply)
      [32m+[0m[0m hostname                                    = (known after apply)
      [32m+[0m[0m id                                          = (known after apply)
      [32m+[0m[0m image                                       = (known after apply)
      [32m+[0m[0m init                                        = (known after apply)
      [32m+[0m[0m ipc_mode                                    = (known after apply)
      [32m+[0m[0m log_driver                                  = (known after apply)
      [32m+[0m[0m logs                                        = false
      [32m+[0m[0m must_run                                    = true
      [32m+[0m[0m name                                        = "tutorial-container"
      [32m+[0m[0m network_data                                = (known after apply)
      [32m+[0m[0m read_only                                   = false
      [32m+[0m[0m remove_volumes                              = true
      [32m+[0m[0m restart                                     = "no"
      [32m+[0m[0m rm                                          = false
      [32m+[0m[0m runtime                                     = (known after apply)
      [32m+[0m[0m security_opts                               = (known after apply)
      [32m+[0m[0m shm_size                                    = (known after apply)
      [32m+[0m[0m start                                       = true
      [32m+[0m[0m stdin_open                                  = false
      [32m+[0m[0m stop_signal                                 = (known after apply)
      [32m+[0m[0m stop_timeout                                = (known after apply)
      [32m+[0m[0m tty                                         = false
      [32m+[0m[0m wait                                        = false
      [32m+[0m[0m wait_timeout                                = 60

      [32m+[0m[0m healthcheck (known after apply)

      [32m+[0m[0m labels (known after apply)

      [32m+[0m[0m ports {
          [32m+[0m[0m external = 8080
          [32m+[0m[0m internal = 80
          [32m+[0m[0m ip       = "0.0.0.0"
          [32m+[0m[0m protocol = "tcp"
        }
    }

[1m  # docker_image.nginx_image[0m will be created
[0m  [32m+[0m[0m resource "docker_image" "nginx_image" {
      [32m+[0m[0m id           = (known after apply)
      [32m+[0m[0m image_id     = (known after apply)
      [32m+[0m[0m keep_locally = false
      [32m+[0m[0m name         = "nginx:latest"
      [32m+[0m[0m repo_digest  = (known after apply)
    }

[1mPlan:[0m 2 to add, 0 to change, 0 to destroy.
[0m[0m[1mdocker_image.nginx_image: Creating...[0m[0m
[0m[1mdocker_image.nginx_image: Still creating... [00m10s elapsed][0m[0m
[0m[1mdocker_image.nginx_image: Creation complete after 19s [id=sha256:84ec966e61a8c7846f509da7eb081c55c1d56817448728924a87ab32f12a72fbnginx:latest][0m
[0m[1mdocker_container.nginx_container: Creating...[0m[0m
[0m[1mdocker_container.nginx_container: Creation complete after 2s [id=0078af356fffe6e2cb3972803916c2a96d45015bdd0f4d5dd466bc7e343f94b7][0m
[0m[1m[32m
Apply complete! Resources: 2 added, 0 changed, 0 destroyed.
[0m
# Terraform-specific
*.tfstate
.tfstate.
.terraform.lock.hcl
.terraform/
Terraform used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
  [32m+[0m create[0m

Terraform will perform the following actions:

[1m  # docker_container.nginx_container[0m will be created
[0m  [32m+[0m[0m resource "docker_container" "nginx_container" {
      [32m+[0m[0m attach                                      = false
      [32m+[0m[0m bridge                                      = (known after apply)
      [32m+[0m[0m command                                     = (known after apply)
      [32m+[0m[0m container_logs                              = (known after apply)
      [32m+[0m[0m container_read_refresh_timeout_milliseconds = 15000
      [32m+[0m[0mâ€¦
[0m[1mdocker_image.nginx_image: Refreshing state... [id=sha256:84ec966e61a8c7846f509da7eb081c55c1d56817448728924a87ab32f12a72fbnginx:latest][0m
[0m[1mdocker_container.nginx_container: Refreshing state... [id=0078af356fffe6e2cb3972803916c2a96d45015bdd0f4d5dd466bc7e343f94b7][0m

Terraform used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
  [31m-[0m destroy[0m

Terraform will perform the following actions:

[1m  # docker_container.nginx_container[0m will be [1m[31mdestroyed[0m
[0m  [31m-[0m[0m resource "docker_container" "nginx_container" {
      [31m-[0m[0m attach                                      = false [90m-> null[0m[0m
      [31m-[0m[0m command     â€¦
init.log
[0m[1mInitializing the backend...[0m
[0m[1mInitializing provider plugins...[0m
- Finding kreuzwerker/docker versions matching "~> 3.0.1"...
- Installing kreuzwerker/docker v3.0.2...
- Installed kreuzwerker/docker v3.0.2 (self-signed, key ID [0m[1mBD080C4571C6104C[0m[0m)
Partner and community providers are signed by their developers.
If you'd like to know more about provider signing, you can read about it here:
https://developer.hashicorp.com/terraform/cli/plugins/signing
Terraform has created a lock file [1m.terraform.lock.hcl[0m to record the provider
selections it made above. Include this file in your version control repository
so that Terraform can guarantee to make the same selections by default when
you run "terraform init" in the future.[0m

â€¦
main.tf
# 1. Configure the required providers
terraform {
  required_providers {
    docker = {
      source  = "kreuzwerker/docker"
      version = "~> 3.0.1"
    }
  }
}

# 2. Configure the Docker provider
provider "docker" {}

# 3. Pull the latest Nginx image from Docker Hub
resource "docker_image" "nginx_image" {
  name         = "nginx:latest"
  keep_locally = false # Do not keep the image cached locally after destroy
}

# 4. Create a Docker container using the Nginx image
resource "docker_container" "nginx_container" {
  image = docker_image.nginx_image.image_id
  name  = "tutorial-container"

  ports {
    internal = 80
    external = 8080
  }
}
plan.log
Terraform used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
  [32m+[0m create[0m

Terraform will perform the following actions:

[1m  # docker_container.nginx_container[0m will be created
[0m  [32m+[0m[0m resource "docker_container" "nginx_container" {
      [32m+[0m[0m attach                                      = false
      [32m+[0m[0m bridge                                      = (known after apply)
      [32m+[0m[0m command                                     = (known after apply)
      [32m+[0m[0m container_logs                              = (known after apply)
      [32m+[0m[0m container_read_refresh_timeout_milliseconds = 15000
      [32m+[0m[0mâ€¦
This project uses Terraform to automate the provisioning of a local Docker container, illustrating basic DevOps practices.

An Nginx web server operating inside a Docker container is defined, created, and managed using a declarative configuration file (main.tf) in accordance with the Infrastructure as Code (IaC) principles. All code and logs are version-controlled using Git, and the project covers the entire infrastructure lifecycle, from creation (apply) to destruction (destroy).
edit in readme
































